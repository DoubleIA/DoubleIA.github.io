---
layout: post
title: JVM学习笔记：对象的创建与访问
permalink: /jvm/obj_acess
---

上一篇介绍了Java虚拟机的[运行时数据区][area]，我们便可以讨论这样一个问题：Java语言中对象是如何创建、如何访问的？下面主要讨论的便是常用虚拟机HotSpot在Java堆中对象的创建，对象的内存布局以及对象的访问的全部过程。
[area]: {{site.baseurl}}/jvm/memory_model

###对象的创建：

在语言层面上，创建对象(如[克隆][clone]、[反序列化][serial])通常仅仅是一个new关键字而已，而在虚拟机中，对象的创建
又是怎样的呢？
[clone]: http://blog.csdn.net/shootyou/article/details/3945221
[serial]: http://www.cnblogs.com/xdp-gacl/p/3777987.html

1. 虚拟机遇上一条new指令时，首先将去检查该指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表
的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应地类加载过程。【Chp7】

2. 类加载检查通过后，接下来虚拟机将为新生对象分配内存。由上一篇内容可知，对象所需内存大小在类加载完成后便可完全确定
，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
    * 如果Java堆中内存时绝对整齐地，就使用“**指针碰撞**”(Bump the Pointer)方式进行内存分配。
    * 如果Java堆中内存并不是整齐规划的，则使用“**空闲链表**”(Free List)方式进行内存分配。
    * 使用何种分配方式由Java堆是否规则决定，而Java堆是否规则由所采取的垃圾收集器是否带有压缩整理功能。

3. 注意由于对象的创建十分频繁，即使是仅仅修改一个指针所指向的位置，在并发环境下也不是线程安全的，有两种解决方案可以解决这个问题：
    * 对内存空间动作进行同步处理，实际上虚拟机采用[CAS][cas]配上失败重试的方式保证更新的原子性。
    * 把内存分配动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，即**本地线程分配缓冲**(TLAB)。只有TLAB用完并分配新的TLAB时才需要使用同步锁定。
[cas]: http://blog.csdn.net/hsuxu/article/details/9467651

4. 内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一工作也提前至TLAB分配时进行。这一操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序可以访问到这些字段数据类型所对应的零值。接下来，虚拟机要对对象进行必要的设置，将必要的信息存放到**对象头**(Object Header)中，对象头的细节将在后文中介绍。

5. 上面的工作都完成后，从虚拟机的角度看，一个对象已经产生了，但从程序的角度看，对象创建才刚刚开始，初始化方法还未执行，所有字段还都为零。所以，一般来说(由字节码中是否跟随invokespecial决定)，执行new指令后会接着执行初始化方法，将对象按程序员的意图进行初始化，这样一个对象才算完全产生出来。

###对象的内存布局：

对象在内存中存储的布局可以分为3块区域：**对象头**(Header)、**实例数据**(Instance Data)和**对齐填充**(Padding)。

1. 对象头包括两部分信息，一是用于存储对象自身运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在**对象访问定位**中讨论。对于数组，对象头中还必须有一块用于记录数组长度的数据。

2. 实例数据是对象真正存储的有效信息，即代码中定义各种类型字段的内容。这部分存储数据会受虚拟机分配策略和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Points)，可以看出，相同长度的字段总被分配到一起。在满足这个条件的情况下，父类定义的变量会出现在子类之前。当然，如果将CompactFields参数值设为true(默认为true)，那么子类中较窄的变量也可能会插入到父类变量的空隙中。

3. 对齐填充不是必然存在的，也没有特别的含义，仅仅起占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍。对象头部分正好是8字节的整数倍(1倍或2倍)，所以当实例数据没有对齐的时候，就需要通过对齐填充来补全。

###对象的访问定位：

1. Java程序需要通过栈上的reference数据来操作堆上的具体对象。对象的访问方式取决于虚拟机的实现而定，有两种主流的访问方式，一是使用**句柄**，二是使用**直接指针**。
   * 使用句柄，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
   * ![Handler]({{site.url}}/images/handler.png)
   * 使用直接指针，那么Java堆对象的布局中就必须考虑如果放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。
   * ![Pointer]({{site.url}}/images/pointer.png)

2. 这两种方式各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄信息，对象移动时(如垃圾收集时)只会改变句柄中的实例数据指针，而reference本身不需要修改。

3. 使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中十分频繁，所以这种开销积少成多后也是一项非常可观的执行成本。
