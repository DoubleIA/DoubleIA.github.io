---
layout: post
title: 垃圾收集器
permalink: /jvm/gc_m
---

垃圾收集器是内存回收的具体实现，不同厂商不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。本文讨论的时JDK1.7的HotSpot虚拟机(已提供商用G1收集器的版本),这个虚拟机包含所有的收集器如图所示。

![GC]({{site.url}}/images/gc.png)

上图中连线代表他们之间可以搭配使用。虚拟机所处的区域，则表示他们是属于新生代收集器还是老年代收集器。目前还没有最好的收集器出现，也没有万能的收集器，只有针对具体应用最合适的收集器。

###Serial收集器

Serial收集器是最基本、历史最悠久的收集器，JDK1.3.1前是新生代收集唯一的选择。

1. 单线程收集器，这不仅仅意味着它只会使用一个CPU或一条收集线程去完成垃圾收集工作，而且在它进行收集时，必须暂停其他所有的工作线程，直到它收集结束(Stop The World)。
2. “Stop The World”工作实际上由虚拟机在后台自动发起和自动完成。简单而高效(与其他单线程收集器比较)，没有线程交互的开销。使用**复制**算法。
3. 在Client模式下默认为新生代收集器。收集新生代内存时，停顿可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，完全可以接受。

停顿会导致不良的用户体现，但是随着垃圾收集器的发展，从Serial到Parallel，再到Concurrent Mark Sweep乃至Garbage First(G1)，垃圾收集器变得越来越优秀，用户停顿时间不断缩短。然而，这些停顿仍然没有办法完全消除(RTSJ收集器除外)。

###ParNew收集器

ParNew是Serial的多线程版本，除了使用多线程，其余行为与Serial完全一样。这两种收集器也共用了相当多的代码。

1. Server模式下默认的新生代收集器，除了Serial外，目前只有它能与CMS收集器配合工作。是使用-XX:+UseConcMarkSweepGC后的默认新生代收集器，也可以使用-XX:+UseParNewGC强制指定他。
2. 单CPU环境下会不比Serial有更好的效果，甚至因为存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU环节中都不能百分百地保证可以超过Serial。当然在CPU非常多(32个，服务器超过32个逻辑CPU地情况越来越多)环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集线程数。

稍后会接触到几个并发和并行的收集器，在这里简单介绍一下并发和并行的区别：

* **并行**(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
* **并发**(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序继续运行，而垃圾收集程序运行于另一个CPU上。

###Parallel Scavenge收集器

Parallel Scavenge是新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。也被称为“吞吐量优先“收集器。

1. Parallel Scavenge不同于CMS等收集器，CMS等收集器的关注点在于尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的**吞吐量**(Throughput)。吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。
2. 停顿时间越短就越适合需要与用户交互的程序，而高吞吐量可以高效利用CPU时间，尽快完成程序运算任务，适合在后台运算而不需要太多交互的任务。
3. 可以使用-XX:MaxGCPauseMillis设置最大停顿时间，使用-XX:GCTimeRatio直接设置吞吐量大小。注意，把停顿时间设置的稍小一点并不能使垃圾收集速度变得更快，反而会使垃圾收集变得更频繁，会导致吞吐量也降低了。 
4. 设置-XX:+UseAdaptiveSizePolicy后，就不需要手工指定新生代大小(-Xmn)、Eden与Surivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了。这些参数将由虚拟机根据系统性能监控信息动态调整以提供最合适的停顿时间或者最大的吞吐量，这便是**GC自适应**的调节策略(GC Ergonomics)。这是Parallel Scavenge与ParNew的一个重要的区别。

###Serial Old收集器

Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理”算法。主要目的也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要有两大用途：

* 一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。
* 另一种用途是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

关于这两点的细节将稍后介绍。

###Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在JDK1.6中开始提供，在此之前，新生代Parallel Scavenge收集器一直处于尴尬状态。原因是选择了Parallel Scavenge后，老年代除了选择Serial Old外别无选择。因为Parallel Scavenge以及后面将介绍的G1收集器都没有使用传统的GC收集器代码框架，而另外独立实现。所以Parallel Scavenge无法与CMS配合使用。

由于Serial Old的拖累，在老年代很大而且硬件比较高德环境中，Parallel Scavenge和Serial Old这种组合的吞吐量甚至不一定有ParNew加CMS组合给力。直到Parallel Old出现，“吞吐量优先”“收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器的组合方式。

###CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目的的收集器。从名字上可以看出，CMS收集器使用”标记-清除“算法实现，它的运作过程相对复杂一些，整个过程分为4个步骤：

* **初始标记**(CMS initial mark)
* **并发标记**(CMS concurrent mark)
* **重新标记**(CMS remark)
* **并发清除**(CMS concurrent sweep)

其中，**初始标记**和**重新标记**仍然需要“Stop The World”。**初始标记**仅仅只是标记一下GC Roots能直接关联到得对象，速度很多，**并发标记**就是进行GC Roots Tracing的过程，而**重新标记**则是为了修正**并发标记**期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但永远比并发标记短。

由于整个过程中消耗时间最长的**并发标记**和**并发清除**都可以与用户线程一起工作，所以，从总体上来看，CMS收集器的内存收回过程是与用户线程一起执行的。

CMS主要优点已经体现出来了，那就是并发收集、低停顿。所以也称为**并发低停顿收集器**(Concurrent Low Pause Collector)。但是它还远达不到完美，它主要有三个缺点：

1. CMS收集器对CPU资源非常敏感。在并发阶段，会因为占用了一部分线程(或者说CPU)而导致应用变慢，总吞吐量降低。
2. CMS收集器无法处理**浮动垃圾**(Floating Garbage)，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。**浮动垃圾**是指在**并发清除**阶段应用程序产生的垃圾。这使得CMS需要在老年代预留一部分空间以提供并发收集时程序运作使用。CMS收集器在JDK1.5下默认为当老年代使用了68%空间后就被激活。可以通过-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比以降低内存回收次数从而提供更好性能。JDK1.6中，CMS启动阈值提升至92%。如果CMS运行期间预留内存无法满足需要，就会出现一次“Concurrent Mode Failure”失败，这时将临时启动Serial Old，这样停顿时间便更长了。所以-XX:CMSInitiatingOccupancyFraction设置太高容易导致大量“Concurrent Mode Failure”失败，反而性能降低。
3. 最后一个缺点是使用“标记-清除”算法收集结束后会产生大量空间碎片，这将给大对象分配带来很大麻烦，会出现老年代还有很大空间，但无法找到足够连续空间来分配当前对象，不得不触发一次Full GC。设置-XX:+UseCMSCompactAtFullCollection参数，可以在FullGC时开启内存碎片合并整理过程，但然，这会使停顿时间变长(内存整理过程无法并发)。为了减缓每次都进行内存整理所带来的停顿时间延长问题，可以通过设置-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的Full GC后，跟着来一次压缩的Full GC(默认为0代表每次都将执行)。

###G1收集器

G1(Garbage First)收集器是当今收集器技术发展的最前沿成果之一，被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它的使命被赋予为在未来替换掉JDK1.5发布的CMS收集器。与其他GC收集器相比，G1具有如下特点：

1. 并行与并发：充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
2. 分代收集：G1不需要其他收集器配合就能独立管理整个GC堆，采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获得更好地收集效果。
3. 空间整合：整体上基于“标记-整理”算法，局部(两个Region之间)上基于“复制"算法实现，不会产生空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行。
4. 可预测停顿：G1除了追求低停顿外，还建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器特征了。

G1收集器将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region(不需要连续)的集合。此外，G1还有许多细节可以讨论，在这里就不做过多讨论了，还是去看《深入理解Java虚拟机》这本书去吧。码字好累，局部(两个Region之间)上基于“复制"算法实现，不会产生空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行。

G1收集器将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region(不需要连续)的集合。G1收集器的运作大致可以分为以下几个步骤：

* **初始标记**(Initial Marking)
* **并发标记**(Concurrent Marking)
* **最终标记**(Final Marking)
* **筛选回收**(Live Data Counting and Evacuation)

G1还有许多细节可以讨论，在这里就不做过多讨论了，还是去看《深入理解Java虚拟机》这本书去吧。码字好累。。。

###理解GC日志

首先看以下两段典型GC日志：

{% highlight java %}
33.125: [GC [DefNew: 3324K->152K(3712), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]
100.667: [Full GC [Tenured: 0K->210K(10240K0), 0.01419142 secs] 4603K->210K(19456), [Perm : 2999K->2999K(21248)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
{% endhighlight %}

最前面的数字“33.125:”和“100.667:”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，“Full”代表发生了Stop-The-World，如果调用Systm.gc()方法，会出现“[Full GC(System(”。

接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域。这些名称由收集器决定。

后面的“324K->152K(3712K)”含义是“GC前该内存区域已使用的容量->GC后该内存区域已使用的容量(该内存区总容量)”。而在方括号之外的“3324K->152K(11904K)”表示“GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容量)”。

再往后“0.0025925 secs”表示该内存区域GC所占用的时间，单位为秒。user、sys、real分别代表用户态消耗CPU的时间、内核态消耗CPU的时间和操作从开始到结束所经过的**墙钟时间**(Wall Clock Time)。墙钟时间包括各种非运算的等待消耗，user或sys时间超过real时间完全正常，因为多CPU或多核的话，多线程操作会叠加这些CPU时间。
